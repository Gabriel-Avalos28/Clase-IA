# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W8P_m97eAHbgmC6oZQuxW_R58GU5xb6i
"""

import random
from statistics import mean

N = 8

def random_state():
    return [random.randint(0, N-1) for _ in range(N)]

def heuristic(state):
    h = 0
    for i in range(N):
        for j in range(i+1, N):
            if state[i] == state[j] or abs(state[i]-state[j]) == abs(i-j):
                h += 1
    return h

def neighbors(state):
    neighs = []
    for col in range(N):
        for row in range(N):
            if row != state[col]:
                s = state.copy()
                s[col] = row
                neighs.append(s)
    return neighs

def best_neighbors(state):
    neighs = neighbors(state)
    # calcula heurística para todos y h_min
    h_vals = [(heuristic(s), s) for s in neighs]
    h_min = min(h for h, _ in h_vals)
    bests = [s for h, s in h_vals if h == h_min]
    return h_min, bests

def hill_climbing_variant(no_sideways=True, max_sideways=100, random_restart=False, max_restarts=1000):
    """
    Devuelve:
      success (bool), steps (int), restarts_used (int)
    - steps cuenta movimientos realizados (cada cambio de estado = 1 paso)
    - Si random_restart=True se reinicia hasta encontrar solución o hasta max_restarts
    """
    restarts = 0
    steps_total = 0

    # función que realiza una corrida desde un estado inicial, sin reinicios internos
    def run_from(initial_state):
        current = initial_state
        steps = 0
        sideways_count = 0
        while True:
            h_cur = heuristic(current)
            if h_cur == 0:
                return True, steps  # encontró solución (desde este start)
            h_best, bests = best_neighbors(current)
            if h_best < h_cur:
                # Mejora estricta: tomar uno aleatorio entre los mejores
                current = random.choice(bests)
                steps += 1
            elif h_best == h_cur and (not no_sideways) and (sideways_count < max_sideways):
                # Movimiento lateral permitido
                current = random.choice(bests)
                steps += 1
                sideways_count += 1
            else:
                # Atasco sin posibilidad (o límite sideways alcanzado)
                return False, steps

    # Si no hay reinicios, una sola corrida
    if not random_restart:
        start = random_state()
        success, steps = run_from(start)
        return success, steps, restarts

    # Con reinicios: repetir hasta encontrar solución (o hasta max_restarts)
    while restarts < max_restarts:
        start = random_state()
        success, steps = run_from(start)
        steps_total += steps
        restarts += 1
        if success:
            # steps_total incluye pasos usados en intentos previos + este intento exitoso
            return True, steps_total, restarts-1  # restarts-1 = número de reinicios previos (opcional)
        # si no tuvo éxito, continua con nuevo start
    # si supera max_restarts, lo consideramos fracaso (muy raro si max_restarts alto)
    return False, steps_total, restarts

def experiment(trials=3000, mode="plain"):
    successes = 0
    steps_success = []
    steps_fail = []

    for _ in range(trials):
        if mode == "plain":
            success, steps, _ = hill_climbing_variant(no_sideways=True, random_restart=False)
        elif mode == "sideways":
            success, steps, _ = hill_climbing_variant(no_sideways=False, max_sideways=100, random_restart=False)
        else:  # restart
            success, steps, _ = hill_climbing_variant(no_sideways=False, max_sideways=100, random_restart=True, max_restarts=1000)

        if success:
            successes += 1
            steps_success.append(steps)
        else:
            steps_fail.append(steps)

    prob_success = successes / trials
    avg_success = mean(steps_success) if steps_success else 0
    avg_fail = mean(steps_fail) if steps_fail else 0

    return {
        "prob_success": prob_success,
        "avg_steps_success": avg_success,
        "avg_steps_fail": avg_fail,
        "n_successes": successes,
        "n_failures": trials - successes
    }

if __name__ == "__main__":
    random.seed()  # quita si quieres reproducibilidad con seed fijo
    print("Sin movimientos laterales:", experiment(3000, "plain"))
    print("Con movimientos laterales:", experiment(3000, "sideways"))
    print("Con reinicios aleatorios:", experiment(3000, "restart"))
